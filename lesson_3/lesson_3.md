# АТД DoublyLinkedList

В данном занятии нам необходимо реализовать двусвязный список.
При проектировании в целом всегда необходимо задумываться о том, какие компоненты можно переиспользовать, придерживаясь DRY. Ведь в новом классе нам необходимо реализовать по сути просто дополнительный метод left(), но как это сделать правильно - это нам и предстоит узнать.

Возможные варианты реализации: 
1. Наследовать новый класс от класса LinkedList, но тогда при каждом изменении в классе родителе, **необходимо также прописывать эти изменения в классе ребенка и переопределить большинство методов.**
2. Создать абстрактный класс родителя, но проблема та же, что и у первого варианта. **Необходимо будет переопределять методы, которые будут схожи друг с другом.**
3. Сделать DoublyLinkedList родителем LinkedList, тогда необходимо просто скрыть метод родительского класса left(), а другие методы будут работать в двух направлениях, что не будет заметно пользователю. Таким способом можно воспользоваться и пренибречь дополнительной нагрузкой.

Но мы воспользуемся следующим вариантом - реализуем абстрактный частичный родительский класс, в котором определим только общие методы классов детей, а дополнительные методы реализуем непосредственно в детях.

Решение:
```go
type Status int
type ParentLinkedList struct {
	// конструктор
	ParentLinkedList[T]() (ParentLinkedList[T])
	
	// команды:
	
	// предусловие: список не пуст
	// постусловие: курсор находится на первом узле списка
	Head()
	
	// предусловие: список не пуст
	// постусловие: курсор установлен на последний элемент в списке
	Tail()
	
	// предусловие: длина списка не меньше 2 
	// и курсор не стоит на последнем элементе
	// постусловие: курсор сдвинут на один элемент вправо
	Right()
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и справа от текущего узла появился узел
	PutRight[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и слева от текущего узла появился узел
	PutLeft[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка уменьшилась на единицу
	// курсор смещён к правому соседу, если он есть, 
	// в противном случае курсор смещён к левому соседу,
	// если он есть
	Remove()
	
	// постусловие: список очищен от всех элементов
	Clear()
	
	// предусловие: список пуст
	// постуловие: список имеет длину в один элемент
	AddToEmpty[T](value T)
	
	// постулосвие: курсор встанет на следующий от себя элемент, который равен значению аргумента, если такой узел найден
	Find[T](value T)
	
	// постуловие: длина списка увеличилась на 1, добавлен новый элемент в хвост
	AddTail[T](value T)
	
	// предусловие: список не пуст
	// постусловие: значения элемента текущего курсора изменилось на новое
	Replace[T](value T)
	
	// постусловие: все элементы равные значению аргумента - удалены
	RemoveAll[T](value T)
	
	// запросы:
	
	// предусловие: список имеет минимум один элемент
	// постуловие: вернется элемент под курсором в данный момент
	Get[T]() (T)
	
	// постусловие: вернется целое число - количество элементов в списке
	Size() (Size)
	
	// предусловие: список не пуст
	IsHead() ValidCase
	
	// предусловие: список не пуст
	IsTail() ValidCase
	
	// предусловие: список не пуст
	IsValue() ValidCase
	
	// дополнительные запросы
	
	GetHeadStatus() (Status) // успешно; список пуст
	GetTailStatus() (Status) // успешно; список пуст
	GetRightStatus() (Status) // успешно; правее нету элемента
	GetPutRightStatus() (Status) // успешно; список пуст
	GetPutLeftStatus() (Status) // успешно; список пуст
	GetRemoveStatus() (Status) // успешно; список пуст
	GetAddToEmptyStatus() (Status) // успешно
	GetReplaceStatus() (Status) // успешно; список пуст
	GetFindStatus() (Status) // следующий найден; 
                       // следующий не найден; список пуст
    GetGetStatus() (Status) // успешно; список пуст
}

// implements ParentLinkedList
type LinkedList struct {
	// реализация в прошлом занятии
}

// implements ParentLinkedList
type DoublyLinkedList struct {
	// конструктор
	DoublyLinkedList[T]() (DoublyLinkedList[T])
	
	// команды:
	
	// предусловие: список не пуст
	// постусловие: курсор сдвинут на один элемент влево
	Left()
	
	// дополнительные запросы:
	GetLeftStatus() (Status) // успешно; список пуст 
}
```