
**Спецификация:**

Это будет стек и пять допустимых операций над ним:

> [!Спецификация]
> - ***push()***, добавляющая свой аргумент новым верхним элементом в стек;  
> - ***pop()***, возвращающая верхний элемент стека и одновременно удаляющая его;  
> - ***peek()***, возвращающая верхний элемент стека;  
> - ***size()***, возвращающая количество элементов в стеке;  
> - ***clear()***, очищающая весь стек.

Соответственно, необходимо составить АТД, который будет реализовывать спецификацию для Stack. 

Важно помнить, что при реализации АТД важно проектировать тип, не привязываясь к определенному типу (то есть используя обобщения (generics) )
Для начала необходимо формализовать набор требований к нашему АТД, делать мы это будем с помощью следующих шагов:

1. Определить тип реализуемого класса:
	- класс анализа
	- класс реализации
	- класс проектирования
2. Определить основные операции (функции) доступные нашему АТД.
3. Разделить операции на следующие типы:
	- конструкторы (создание нового экземпляра типа)
	- запросы (функции, которые возвращают какие-то данные)
	- команды (функции, которые просто выполняют определенную операцию, меняя значения атрибутов класса, без возврата значения)
> 	**Во всех случаях запросы и команды не должны менять значения своих аргументов (которые, возможно, передаются по ссылке).**

4. Далее необходимо составить ограничения для выполнения операций, прописать -пред и -пост условия
> Каждая операция должна быть полностью автономна и независима от других, а ограничения для неё задаются исключительно с помощью пред- и постусловий. В идеале это подразумевает, что **никакая из операций АТД не может быть выражена через другие операции (все они атомарны)**. Сам по себе это достаточно сильный и чистый подход, и если АТД удаётся наглядно и просто специфицировать таким способом, то так и надо делать. Однако в ООАП довольно активно применяется концепция **классов поведения**, когда некоторые ключевые методы определяются комбинированием низкоуровневых операций. Кроме того, даже разделение на запросы и команды будет противоречить такому минималистичному подходу. И всё же по возможности желательно хотя бы приближаться к этому идеалу.



Конструктор:
- Должен явно возвращать новый экземпляр нашего класса
> Главная идея, что **объекты в программе должны создаваться всегда в согласованном формате и только по явному безопасному запросу, вызовом особой функции класса, которая новые объекты создаёт**.

Команды и запросы:
- Здесь важна обработка именно команд, поскольку по спецификации - запрос возвращает определенное значение, а команда - нет, поэтому надо особым образом определять успешность работы команд, с помощью дополнительных запросов
	Пример:
```
make_command( ... );
status = get_make_status();
```

***Запросы статуса нужны только тем командам и запроса, где явно указано предусловие, которое должно выполнятся!!!***


Реализация:

```go
// АТД Stack
type Status int
type Size int

type Stack [T any]struct {
	stackStorage List[T] // хранилище стека
	peekStatus Status // аттрибут состояния запроса Peek()
	popStatus Status // аттрибут состояния команды Pop()
}

// конструктор (запрос)
// постусловие: создан новый пустой стек
func Stack[T]() (Stack[T]) {
	return Stack[T] {
		stackStorage: [],
		popStatus: POP_NIL,
		peekStatus: PEEK_NIL,
	}
}

Status (
	POP_NIL = iota // Push() еще не вызывалась (нужен для более точной диагностики)
	POP_OK // все корректно, последняя Pop() отработала нормально
	POP_ERR // стек пуст
)

Status (
	PEEK_NIL = iota // Push() еще не вызывалась (нужен для более точной диагностики)
	PEEK_OK // последняя Peek() отработала корректно
	PEEK_ERR // стек пустой
)

// подробная спецификация
type StackInterface[T any] interface {
	// команда
	// постусловие: в стек помещен новый элемент
	Push[T](value T)
	
	// команда
	// предусловие: стек не пустой
	// постусловие: из стека удален верхний элемент
	Pop()
	// запрос
	// возвращается акутальный статус последней выполненной команды Pop()
	GetPopStatus() (Status)
	
	// запрос
	// предусловие: стек не пустой
	// постусловие: вернется верхний элемент из стека
	Peek[T]() (T)
	// запрос
	// возвращается акутальный статус последней выполненного запроса Peek()
	GetPeekStatus() (Status)
	
	// команда
	// постусловие: стек очищен -> удаляются все значения
	Clear()
	
	// запрос
	// постусловие: возвращается размер стека
	Size() (Size)
}

func (s *Stack) Push[T](value T) {
	s.stackStorage.Append(value) 
}

func (s *Stack) Pop() {
	var size Size := s.Size() 
	if size > 0 {
		s.stackStorage.RemoveAt(-1)
		s.popStatus = POP_OK
	} else {
		s.popStatus = POP_ERR
	}
}

func (s *Stack) GetPopStatus() (Status) {
	return s.popStatus
}

func (s *Stack) Peek[T]() (T) {
	var size Size := s.Size()
	var result T 
	if size > 0 {
		result = s.stackStorage[-1]
		s.popStatus = PEEK_OK
	} else {
		s.popStatus = POP_ERR
	}
	
	return result
}

func (s *Stack) GetPeekStatus() (Status) {
	return s.peekStatus
}

func (s *Stack) Clear() {
	// так как List уже реализован,
	// значит у него должен быть конструктор
	// и мы возвращаем пустой List
	s.stackStorage = List()
	
	// устанавливаем начальные статусы
	s.popStatus = POP_NIL
	s.peekStatus = PEEK_NIL
}
func (s *Stack) Size() (Size) {
	return s.stackStorage.Length()
}
```

После того, как мы реализовали АТД Stack, приступаем к данному заданию:

> На основе примера АТД Stack (но не в форме наследования, а как автономное решение) определите АТД BoundedStack и выполните его реализацию. BoundedStack -- это ограниченный стек, конструктор которого получает целое положительное значение, задающее максимально допустимое количество элементов в стеке. Если параметр не задан, конструктор по умолчанию формирует стек максимум на 32 элемента.
> 
> _BoundedStack -- это весьма распространённая прикладная версия стеков, потому что на практике обычно нежелательно позволять стеку неограниченно расти._

Реализация:

```go
// АТД BoundedStack
type Status int
type Size int
type Capacity int

type BoundedStack [T any]struct {
	boundedStackStorage List[T] // хранилище стека
	capacity Capacity // заданная вместимость хранилища, по-умолчанию: 32
	peekStatus Status // аттрибут состояния запроса Peek()
	popStatus Status // аттрибут состояния команды Pop()
	pushStatus Status // аттрибут состояния команды Push(), надо контроллировать переполнение
}

Capacity DEFAULT_CAP = 32

Status (
	POP_NIL = iota // Push() еще не вызывалась (нужен для более точной диагностики)
	POP_OK // все корректно, последняя Pop() отработала нормально
	POP_ERR // стек пуст
)

Status (
	PEEK_NIL = iota // Push() еще не вызывалась (нужен для более точной диагностики)
	PEEK_OK // последняя Peek() отработала корректно
	PEEK_ERR // стек пустой
)

Status (
	PUSH_NIL = iota // стек пуст
	PUSH_OK // последняя Push() отработала корректно
	PUSH_ERR // стек заполнен
)

// конструктор (запрос)
// постусловие: создан новый пустой стек с заданной вместимостью (Capacity)
func BoundedStack[T](cap ...Capacity) (BoundedStack[T]) {
	capacity := DEFAULT_CAP // немного громоздкая обработка необязательных аргументов в Go
	if len(cap) > 0 {
		capacity = cap[0]
	}
	
	storage := List(capacity)
	return BoundedStack[T]{
		boundedStackStorage: storage,
		capacity: capacity,
		peekStatus: PEEK_NIL,
		popStatus: POP_NIL,
		pushStatus: PUSH_NIL,
	}
}

// подробная спецификация
type BoundedStackInterface[T any] interface {
	// команда
	// предусловие: стек не заполнен
	// постусловие: в стек помещен новый элемент
	Push[T](value T)
	// запрос
	// возвращается акутальный статус последней выполненной команды Push()
	GetPushStatus() (Status)
	
	// команда
	// предусловие: стек не пустой
	// постусловие: из стека удален верхний элемент
	Pop()
	// запрос
	// возвращается акутальный статус последней выполненной команды Pop()
	GetPopStatus() (Status)
	
	// запрос
	// предусловие: стек не пустой
	// постусловие: вернется верхний элемент из стека
	Peek[T]() (T)
	// запрос
	// возвращается акутальный статус последней выполненного запроса Peek()
	GetPeekStatus() (Status)
	
	// команда
	// постусловие: стек очищен -> удаляются все значения
	Clear()
	
	// запрос
	// постусловие: возвращается размер стека
	Size() (Size)
}

func (s *BoundedStack) Push[T](value T) {
	var size Size := s.Size()
	if size == s.capacity {
		s.pushStatus = PUSH_ERR
	} else {
		s.boundedStackStorage.Append(value) 
		s.pushStatus = PUSH_OK
	}
}

func (s *BoundedStack) GetPushStatus() (Status) {
	return s.pushStatus
}

func (s *BoundedStack) Pop() {
	var size Size := s.Size() 
	if size > 0 {
		s.boundedStackStorage.RemoveAt(-1)
		s.popStatus = POP_OK
	} else {
		s.popStatus = POP_ERR
	}
}

func (s *BoundedStack) GetPopStatus() (Status) {
	return s.popStatus
}

func (s *BoundedStack) Peek[T]() (T) {
	var size Size := s.Size()
	var result T 
	if size > 0 {
		result = s.boundedStackStorage[-1]
		s.popStatus = PEEK_OK
	} else {
		s.popStatus = POP_ERR
	}
	
	return result
}

func (s *BoundedStack) GetPeekStatus() (Status) {
	return s.peekStatus
}

func (s *BoundedStack) Clear() {
	// так как List уже реализован,
	// значит у него должен быть конструктор
	// и мы возвращаем пустой List
	s.boundedStackStorage = List(s.capacity)
	
	// устанавливаем начальные статусы
	s.popStatus = POP_NIL
	s.peekStatus = PEEK_NIL
	s.pushStatus = PUSH_NIL
}

func (s *Stack) Size() (Size) {
	return s.stackStorage.Length()
}
```