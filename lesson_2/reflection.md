# Рефлексия

Эталонное решение:

```java
abstract class LinkedList<T>

  // конструктор
// постусловие: создан новый пустой список
  public LinkedList<T> LinkedList();

  // команды
// предусловие: список не пуст; 
// постусловие: курсор установлен на первый узел в списке
  public void head(); 

// предусловие: список не пуст; 
// постусловие: курсор установлен на последний узел в списке
  public void tail(); 

// предусловие: правее курсора есть элемент; 
// постусловие: курсор сдвинут на один узел вправо
  public void right(); 

// предусловие: список не пуст; 
// постусловие: следом за текущим узлом добавлен 
// новый узел с заданным значением
  public void put_right(T value); 

// предусловие: список не пуст; 
// постусловие: перед текущим узлом добавлен 
// новый узел с заданным значением
  public void put_left(T value); 

// предусловие: список пуст; 
// постусловие: в списке один узел
  public void add_to_empty(T value); 

 // предусловие: список не пуст; 
// постусловие: текущий узел удалён, 
// курсор смещён к правому соседу, если он есть, 
// в противном случае курсор смещён к левому соседу,
// если он есть
  public void remove();

// постусловие: список очищен от всех элементов
  public void clear(); 

// постусловие: новый узел добавлен в хвост списка
  public void add_tail(T value); 

// постусловие: в списке удалены все узлы с заданным значением
  public void remove_all(T value);

// предусловие: список не пуст;
// постусловие: значение текущего узла заменено на новое
  public void replace(T value); 

// постусловие: курсор установлен на следующий узел 
// с искомым значением, если такой узел найден
  public void find(T value); 

  // запросы
  public T get(); // предусловие: список не пуст
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();

  // запросы статусов (возможные значения статусов)
  public int get_head_status(); // успешно; список пуст
  public int get_tail_status(); // успешно; список пуст
  public int get_right_status(); // успешно; правее нету элемента
  public int get_put_right_status(); // успешно; список пуст
  public int get_put_left_status(); // успешно; список пуст
  public int get_add_to_empty_status(); // успешно
  public int get_remove_status(); // успешно; список пуст
  public int get_replace_status(); // успешно; список пуст
  public int get_find_status(); // следующий найден; 
                       // следующий не найден; список пуст
  public int get_get_status(); // успешно; список пуст
```

После анализа эталонного решения я выявил несколько недочетов:
1. Нет конструктора!!! (ужас, сказалась невнимательность)
2. Описание состояний для дополнительных запросов есть в переменных состояний, возле самих запросов нет
3. Написал состояние для команды *find*, но не написал дополнительный запрос на состояние
4. Не написал дополнительный запрос на запрос *get*
5. Также добавил в свое решение атрибуты, в которых хранятся состояния, а также сущность курсора, как указатель на тип, возможно не совсем правильно определил курсор
6. Не совсем верно определил постусловие для команды *remove*, а также предусловие для команд: *add_tail, remove_all*
7. Неверно определил состояния для команды *find*

Решение оценю на оценку хорошо, так как большее количество запросов и команд определены верно, также правильно определены, почти везде , -пост и -пред условия. Из-за невнимательности допустил несколько ошибок, также видимо слишком сильно задумывался над решением, от чего реализация получилась слишком громоздкой (это может сыграть важную роль при проектировании систем, ведь закапывание на таком месте может затянуть разработку), можно было более минимально.

Решение после рефлексии:

```go

type Size int
type Status int
type ValidCase bool

Status (
	HEAD_NIL = iota // AddToEmpty() еще не вызывалась
	HEAD_OK // все корректно, последний вызов Head() отработал нормально
	HEAD_ERR // список пуст
)

Status (
	TAIL_NIL = iota // AddToEmpty() еще не вызывалась
	TAIL_OK // все корректно, последний вызов Tail() отработал нормально
	TAIL_ERR // список пуст
)

Status (
	RIGHT_LEN_ERR = iota + 1 // длина списка меньше 2
	RIGHT_CURSOR_ERR // курсор на последнем элементе
	RIGHT_OK // последний Right() отработал нормально, курсор не на последнем элементе и длина списка больше 2
	
)

Status (
	PUT_RIGHT_NIL = iota // AddToEmpty() еще не вызывалась
	PUT_RIGHT_OK // все корректно, последний PutRight() отработал нормально 
	PUT_RIGHT_ERR // список пуст
)

Status (
	PUT_LEFT_NIL = iota // AddToEmpty() еще не вызывалась
	PUT_LEFT_OK // все корректно, последний PutLeft() отработал нормально
	PUT_LEFT_ERR // список пуст
)

Status (
	REMOVE_NIL = iota // AddToEmpty() еще не вызывалась
	REMOVE_OK // все корректно, последний Remove() выполнился нормально, количество элементов в списке не меньше 1
	REMOVE_ERR // список пуст
)

Status (
	ADD_TO_EMPTY_OK = iota + 1 // AddToEmpty() еще не вызывалась 
	ADD_TO_EMPTY_ERR // последний AddToEmpty() отработал нормально, в списке есть один элемент, больше для одного экземпляра списка вызывать нельзя
)

Status (
	ADD_TAIL_NIL = iota // AddToEmpty() еще не вызывалась
	ADD_TAIL_OK // все корректно, последний AddTail() отработал нормально и курсор находится на последнем элементе 
	ADD_TO_TAIL_LEN_ERR // список пуст
	ADD_TO_TAIL_CURSOR_ERR // курсор стоит не на последнем элементе 
)

Status (
	REPLACE_NIL = iota // AddToEmpty() еще не вызывалась
	REPLACE_OK // все корректно, последний Replace() отработал корректно 
	REPLACE_ERR // список пуст
)

Status (
	REMOVE_ALL_NIL = iota // AddToEmpty() еще не вызывалась
	REMOVE_ALL_OK // все корректно, последний RemoveAll() отработал нормально 
	REMOVE_ALL_ERR // список пуст
)

Status (
	FIND_NIL = iota // AddToEmpty() еще не вызывалась
	FIND_OK // все корректно, последний Find() отработал нормально
	FIND_NOT_OK // все корректно, последний Find() не нашел следующего элемента 
	FIND_ERR // список пуст
)

Status (
	GET_NIL = iota // AddToEmpty() еще не вызывалась, список пуст
	FIND_OK // все корректно, последний Get() отработал нормально
)

type LinkedList[T any] struct {
	// статусы команд с предусловиями
	headStatus Status
	tailStatus Status
	rightStatus Status
	putRightStatus Status
	putLeftStatus Status
	removeStatus Status
	addToEmptyStatus Status
	getStatus Status
	replaceStatus Status
	removeAllStatus Status
	findStatus Status
	
	cursorPoint *T // положение курсора - указатель на тип
}

type LinkedListInterface[T any] interface {
	// конструктор
	LinkedList[T]() (LinkedList[T])
	
	// команды:
	
	// предусловие: список не пуст
	// постусловие: курсор находится на первом узле списка
	Head()
	
	// предусловие: список не пуст
	// постусловие: курсор установлен на последний элемент в списке
	Tail()
	
	// предусловие: длина списка не меньше 2 
	// и курсор не стоит на последнем элементе
	// постусловие: курсор сдвинут на один элемент вправо
	Right()
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и справа от текущего узла появился узел
	PutRight[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и слева от текущего узла появился узел
	PutLeft[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка уменьшилась на единицу
	// курсор смещён к правому соседу, если он есть, 
	// в противном случае курсор смещён к левому соседу,
	// если он есть
	Remove()
	
	// постусловие: список очищен от всех элементов
	Clear()
	
	// предусловие: список пуст
	// постуловие: список имеет длину в один элемент
	AddToEmpty[T](value T)
	
	// постулосвие: курсор встанет на следующий от себя элемент, который равен значению аргумента, если такой узел найден
	Find[T](value T)
	
	// постуловие: длина списка увеличилась на 1, добавлен новый элемент в хвост
	AddTail[T](value T)
	
	// предусловие: список не пуст
	// постусловие: значения элемента текущего курсора изменилось на новое
	Replace[T](value T)
	
	// постусловие: все элементы равные значению аргумента - удалены
	RemoveAll[T](value T)
	
	// запросы:
	
	// предусловие: список имеет минимум один элемент
	// постуловие: вернется элемент под курсором в данный момент
	Get[T]() (T)
	
	// постусловие: вернется целое число - количество элементов в списке
	Size() (Size)
	
	// предусловие: список не пуст
	IsHead() ValidCase
	
	// предусловие: список не пуст
	IsTail() ValidCase
	
	// предусловие: список не пуст
	IsValue() ValidCase
	
	// дополнительные запросы
	
	GetHeadStatus() (Status)
	GetTailStatus() (Status)
	GetRightStatus() (Status)
	GetPutRightStatus() (Status)
	GetPutLeftStatus() (Status)
	GetRemoveStatus() (Status)
	GetAddToEmptyStatus() (Status)
	GetReplaceStatus() (Status)
	GetFindStatus() (Status)
	GetGetStatus() (Status)
	
}
```

