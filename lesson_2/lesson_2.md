# АТД Linked List

Спецификация:

Реализация, которую мы делали в рамках курса АСД1 нам не подходит в виду нескольких причин:
- методы не согласованы между собой по аргументам, где то мы работаем со значениями напрямую, где-то используем чисто узлы;
- при поиске узла м выбираем первый попавшийся;

> В общем случае, переходя на уровень АТД, мы и должны думать только соответствующими абстракциями. А таких **абстракций на уровне АТД всего две: это сам связный список, и хранимые в нём значения**. Опускаясь же на уровень текущей реализации в виде данного шаблона, мы предлагаем совсем другой, более слабый уровень абстракции -- узлы списка и связи между ними. Кроме того, желательно, как уже отмечалось, чтобы АТД предлагал по возможности минималистичный набор операций, для работы которых не требовалось бы выполнять какие-то предварительные действия (например, создание или поиск узлов).

Нам необходима та спецификация, в которой будут минималистичные методы, а также мы будем работать с определенной сильной абстракцией. Решением данной проблемы - использование **Курсора** и набор следующих методов:

> [!Спецификация]
> В таком случае можно обойтись набором из девяти атомарных (не сводимых друг к другу) операций:
> 
> -- head -- установить курсор на первый узел в списке;
> -- tail -- установить курсор на последний узел в списке;
> -- right -- сдвинуть курсор на один узел вправо;
> -- get -- получить значение текущего узла;
> -- put_right(значение) -- вставить следом за текущим узлом 
>                       новый узел с заданным значением;
> -- put_left(значение) -- вставить перед текущим узлом 
>                       новый узел с заданным значением;
> -- remove -- удалить текущий узел 
>              (курсор смещается к правому соседу, если он есть, 
>               в противном случае курсор смещается к левому соседу, 
>               если он есть);
> -- clear -- очистить список;
> -- size -- посчитать количество узлов в списке;
> -- add_to_empty(значение) -- добавить новый узел в пустой список.
> 
> Кроме того, из соображений эффективности и удобства пользователей желательно добавить такие операции (хотя они и сводимы к другим элементарным операциям):
> 
> -- add_tail(значение) -- добавить новый узел в хвост списка;
> -- replace(значение) -- заменить значение текущего узла на заданное;
> -- find(значение) -- установить курсор на следующий узел 
>                   с искомым значением (по отношению к текущему узлу);
> -- remove_all(значение) -- удалить в списке все узлы с заданным значением;
> -- is_head -- находится ли курсор в начале списка?
> -- is_tail -- находится ли курсор в конце списка?
> -- is_value -- установлен ли курсор на какой-либо узел в списке 
>               (по сути, непустой ли список).

1. Для начала необходимо выписать всю спецификацию, которую необходимо разработать в задании
2. Разделить методы спецификации на команды и запросы
3. Выписать для каждого метода в группе (команды и запросы) -пост и -пред условия
4. При необходимости указать дополнительные запросы для команд, которые изменяют состояние объекта
5. Также добавить необходимые состояния для команд 
```go

type Size int
type Status int
type ValidCase bool

Status (
	HEAD_NIL = iota // AddToEmpty() еще не вызывалась
	HEAD_OK // все корректно, последний вызов Head() отработал нормально
	HEAD_ERR // список пуст
)

Status (
	TAIL_NIL = iota // AddToEmpty() еще не вызывалась
	TAIL_OK // все корректно, последний вызов Tail() отработал нормально
	TAIL_ERR // список пуст
)

Status (
	RIGHT_LEN_ERR = iota + 1 // длина списка меньше 2
	RIGHT_CURSOR_ERR // курсор на последнем элементе
	RIGHT_OK // последний Right() отработал нормально, курсор не на последнем элементе и длина списка больше 2
	
)

Status (
	PUT_RIGHT_NIL = iota // AddToEmpty() еще не вызывалась
	PUT_RIGHT_OK // все корректно, последний PutRight() отработал нормально 
	PUT_RIGHT_ERR // список пуст
)

Status (
	PUT_LEFT_NIL = iota // AddToEmpty() еще не вызывалась
	PUT_LEFT_OK // все корректно, последний PutLeft() отработал нормально
	PUT_LEFT_ERR // список пуст
)

Status (
	REMOVE_NIL = iota // AddToEmpty() еще не вызывалась
	REMOVE_OK // все корректно, последний Remove() выполнился нормально, количество элементов в списке не меньше 1
	REMOVE_ERR // список пуст
)

Status (
	ADD_TO_EMPTY_OK = iota + 1 // AddToEmpty() еще не вызывалась 
	ADD_TO_EMPTY_ERR // последний AddToEmpty() отработал нормально, в списке есть один элемент, больше для одного экземпляра списка вызывать нельзя
)

Status (
	ADD_TAIL_NIL = iota // AddToEmpty() еще не вызывалась
	ADD_TAIL_OK // все корректно, последний AddTail() отработал нормально и курсор находится на последнем элементе 
	ADD_TO_TAIL_LEN_ERR // список пуст
	ADD_TO_TAIL_CURSOR_ERR // курсор стоит не на последнем элементе 
)

Status (
	REPLACE_NIL = iota // AddToEmpty() еще не вызывалась
	REPLACE_OK // все корректно, последний Replace() отработал корректно 
	REPLACE_ERR // список пуст
)

Status (
	REMOVE_ALL_NIL = iota // AddToEmpty() еще не вызывалась
	REMOVE_ALL_OK // все корректно, последний RemoveAll() отработал нормально 
	REMOVE_ALL_ERR // список пуст
)

Status (
	FIND_NIL = iota // AddToEmpty() еще не вызывалась
	FIND_OK // все корректно, последний Find() отработал нормально 
	FIND_ERR // список пуст
)

type LinkedList[T any] struct {
	// статусы команд с предусловиями
	headStatus Status
	tailStatus Status
	rightStatus Status
	putRightStatus Status
	putLeftStatus Status
	removeStatus Status
	addToEmptyStatus Status
	addTailStatus Status
	replaceStatus Status
	removeAllStatus Status
	findStatus Status
	
	cursorPoint *T // положение курсора - указатель на тип
}

type LinkedListInterface[T any] interface {
	// команды:
	
	// предусловие: список не пуст
	// постусловие: курсор находится на первом узле списка
	Head()
	
	// предусловие: список не пуст
	// постусловие: курсор установлен на последний элемент в списке
	Tail()
	
	// предусловие: длина списка не меньше 2 
	// и курсор не стоит на последнем элементе
	// постусловие: курсор сдвинут на один элемент вправо
	Right()
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и справа от текущего узла появился узел
	PutRight[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка увеличилась на 1
	// и слева от текущего узла появился узел
	PutLeft[T](value T)
	
	// предусловие: список не пуст
	// постусловие: длина списка уменьшилась на единицу, курсор изменил свое положение
	Remove()
	
	// постусловие: список очищен от всех элементов
	Clear()
	
	// предусловие: список пуст
	// постуловие: список имеет длину в один элемент
	AddToEmpty[T](value T)
	
	// предусловие: список не пуст
	// постулосвие: курсор встанет на следующий от себя элемент, который равен значению аргумента
	Find[T](value T)
	
	// предусловие: курсор на последнем элементе
	// постуловие: длина списка увеличилась на 1, добавлен новый элемент в хвост
	AddTail[T](value T)
	
	// предусловие: список не пуст
	// постусловие: значения элемента текущего курсора изменилось
	Replace[T](value T)
	
	// предусловие: список не пуст
	// постусловие: все элементы равные значению аргумента - удалены
	RemoveAll[T](value T)
	
	// запросы:
	
	// предусловие: список имеет минимум один элемент
	// постуловие: вернется элемент под курсором в данный момент
	Get[T]() (T)
	
	// постусловие: вернется целое число - количество элементов в списке
	Size() (Size)
	
	// предусловие: список не пуст
	IsHead() ValidCase
	
	// предусловие: список не пуст
	IsTail() ValidCase
	
	// предусловие: список не пуст
	IsValue() ValidCase
	
	// дополнительные запросы
	
	GetHeadStatus() (Status)
	GetTailStatus() (Status)
	GetRightStatus() (Status)
	GetPutRightStatus() (Status)
	GetPutLeftStatus() (Status)
	GetRemoveStatus() (Status)
	GetAddToEmptyStatus() (Status)
	GetAddTailStatus() (Status)
	GetReplaceStatus() (Status)
	GetRemoveAllStatus() (Status)
	
}

```

Ответы на вопросы:

1. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?

*Если сводить эту операцию к другим, то мы придем к неэффективному варианту с перебором всех значений.* 

2. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?

*Мы сможем это сделать с помощью Head(), Tail() ,Find(), Get().* 
